<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <link rel="stylesheet" href="page.css">
  <script src="jquery-3.5.1.min.js"></script>
  <script src="page.js"></script>
  <title>Everything I know about random number generation.</title>
</head>
<body class="font0">
  <div class="fullwidth title">
    <h1>Everything I know about random number generation <img id="dice" src="dice/1-0.png" onClick="rollDice(); return false;"></h1>
    <!-- rollDice uses a cryptographically secure random number generator! -->
    <div class="subtitle">A page dedicated to random, pseudo-random, cryptographic, secure, and other number generators.</div>
  </div>

  <div class="container">
    <p align="right">Last updated: Apr 2021</p>
  <h2>Table of content</h2>
  <ol id="toc">
  </ol>

  <h2 class="count">Introduction</h2>
  <p>
    Computers use Random Number Generators (RNGs) to create sequences of
    seemingly random numbers. For example, figure 1 is different everytime you
    load this page. Each pixel has equal likelihood of being black or white. The
    result is called a white noise image.
  </p>

  <p>
    Not all RNGs are equal. For example, Linear Congruential Generators (LCG), a
    type of pseudo-random number generator (PRNG), popular until the
    mid to late 1990s, yields poor quality results (figure 2); often resulting in
    visible structure when rendered in graphical form.
  </p>

  <p>
    Random number generation is a fascinating topic. It impacts many areas of
    computer science (cryptography, simulations and experiments, generative art,
    testing, fuzzing, etc.). In addition, there's a history of failures we can learn
    from — real world RNGs are more complicated than you might think at
    first glance.
  </p>

  <p>
    The audiance for this page are software engineers or the technically
    inclined who are interested to learn more about how RNGs work <i>at a high
    level</i>. The depth and breadth of the information is comparable to what
    you would find on Wikipedia. Hopefully, having all the information gathered
    in a single page makes the content more delightful to read.
  </p>

  <div style="display: grid; grid-template-columns: 1fr 1fr 1fr">
    <div>
      <canvas id="fig1"></canvas>
      <div>Figure 1: white noise. <a href="" onClick="genWhiteNoise(true); return false"><img id="genWhiteNoiseImg" class="refresh" src="refresh.svg"></a></div>
    </div>
    <div>
      <canvas id="fig2"></canvas>
      <div>Figure 2: LCG. <a href="" onClick="genLCG(true); return false"><img id="genLCGImg" class="refresh" src="refresh.svg"></a></div>
    </div>
  </div>

  <h2 class="count">Contributors</h2>
  <p>
    This page was authored by <a href="https://quaxio.com/">Alok
    Menghrajani</a>. The following peers helped by either directly contributing
    content, proof reading a draft version, or providing constructive feedback
    along the way.
  </p>
  <p>
    Interested to work with us at Square? Many teams are
    hiring, visit <a href="https://squareup.com/careers">https://squareup.com/careers</a>
    to browse job openings.
  </p>

  <p>
    This page is hosted on GitHub, feel free to open an <a href="https://github.com/alokmenghrajani/alokmenghrajani.github.com/issues">Issue</a>
    or a <a href="https://github.com/alokmenghrajani/alokmenghrajani.github.com/pulls">Pull Request</a>
    to report any mistakes or suggest corrections or additional material. Please indicate
    if you would like your name included below.
    You may also use the <a href="https://github.com/alokmenghrajani/alokmenghrajani.github.com/discussions">Discussions</a>
    feature to ask any question or start a discussion.
  </p>

  <p>In random order (obligatory) <a href="" onClick="updateContributors(true); return false"><img id="updateContributorsImg" class="refresh" src="refresh.svg"></a>:</p>
    <ul id="contributors">
      <li>Oscar</li>
      <li>Alex</li>
      <li>Michael Weissbacher</li>
    </ul>

  <h2 class="count">Overview</h2>
  <p>
    A random number generator (RNG) is a process which generates a sequence of numbers. A good RNG will
    generate each possible sequence with equal probability (no bias) and
    in an unpredictable way.
  </p>
  <p>
    Before looking at how RNGs work, let's go over a short list of applications
    where a RNG comes into play:
    <ul>
      <li>
        <b>Cryptography</b>: cryptographic protocols require randomly generating
        keys, nonces, and/or salts. This data must be unguessable, requiring a
        RNG with the highest level of unpredictability. RNG failures can lead to
        ciphertext getting decrypted, cryptocurrency loss, or other unfortunate
        outcomes. Random number generators designed for cryptographic
        applications are sometimes referred to as True Random Number Generators
        (TRNG), cryptographically secure pseudorandom number generator (CSPRNG,
        sometimes abbreviated as CPRNG or just CRNG).
      </li>
      <li>
        <b>Casino/lottery games</b>: an attacker who can predict future cards
        can turn the winning odds in their favor. The scheme is easy to
        monetize, making it attractive for attackers. In addition, an insider
        attacker might subvert how the random number generation happens or how
        the stream of random data gets used in order to create a subtle
        weakness.
      </li>
      <li>
        <b>Simulations and science experiments</b>: reproducibility
        is often a desirable property. Using a deterministic process to generate
        random numbers, i.e. pseudo-random number generator (PRNG), implies you
        can share the seed and have other people verify your results. You
        however need the highest level of unpredictability, or you risk
        affecting the results and making incorrect conclusions. You likely also
        want a way to prove that the seed you picked was itself randomly
        generated in a trustworthy way.
      </li>
      <li><b>Random selection affecting people</b>: humans tend to think irrationally
        about random events. Positive events are considered in terms of luck
        or destiny. Negative events are considered unfair. This can lead to
        situations where the random generation process needs to be verifiable.
        In general, it is very hard to fully verify computer-related processes,
        since the entire supply chain security needs to be taken into consideration.
      </li>
      <li>
        <b>Data structures</b>: hash tables often need to mitigate the risk of
        an attacker degrading the performance of the data structure by carefully
        crafted keys. A cryptographic hash function would work but would add
        significant overhead. The typical solution is to use a weaker but faster
        hashing algorithm and seed it with a randomly generated seed. Another
        similar use-case is randomization of address space and stack
        canaries. The goal is to make it harder for an attacker
        to exploit buffer or stack overflows.
      </li>
      <li>
        <b>Lots of other applications</b>: video games,
        image processing, generative art, testing, fuzzing, etc. In most other
        applications, the speed and reproducibility might be more important than
        the fact that the sequence needs to be unguessable.
      </li>
    </ul>
  </p>

  <p>
    An entropy source is very similar to a RNG, but typically produces random
    events in a slow and irregular fashion. The entropy source can be a
    Hardware Random Number Generator (HWRNG) or simply external events unlikely
    to be predictable (timing between keystrokes or network packet arrival rate).
  </p>

  <p>
    Engineers building RNGs combine different elements. For example, they might
    use an entropy source to feed a PRNG. Or they might combine two RNGs with a
    hash function. The end result is a simle API to randomly generate numbers.
    Building a RNG requires balancing various tradeoffs: the entropy source
    might be biased, external events might not be available during system boot,
    entropy estimation techniques, blocking vs non-blocking when entropy is low,
    etc.
  </p>

  <h2 class="count">Hardware Random Number Generator</h2>
  <p>
    Hardware random number generators (HWRNGs) derive randomness by measuring a physical
    process. For example a diode can be used to measure electrical
    noise<span class="footnote"><a href="https://en.wikipedia.org/wiki/Noise_generator">https://en.wikipedia.org/wiki/Noise_generator</a></span>.
    Other common techniques include measuring the difference between multiple
    oscillators. A camera pointed at lava lamps<span class="footnote"><a href="https://en.wikipedia.org/wiki/Lavarand">https://en.wikipedia.org/wiki/Lavarand</a>
      and <a href="https://www.atlasobscura.com/places/encryption-lava-lamps">https://www.atlasobscura.com/places/encryption-lava-lamps</a></span>
    can also serve as a makeshift RNG.
  </p>
  <p>
    HWRNGs can be categorized based on whether the measurement is a classical
    physical property or a quantum random property, with the later devices being
    significantly more expensive. Classical properties can theoritically be
    predicted by an observer or influenced from the outside. Based on our
    current understanding of physics, quantum properties can neither be predicted
    nor influenced by an external actor.
  </p>
  <p>
    Most modern computers have at least two different HWRNGs: the secure enclave/TPM
    and the processor. Both devices provide the ability to generate random numbers. In
    addition, it is possible to time jitter<span class="footnote"><a href="https://www.chronox.de/jent/doc/CPU-Jitter-NPTRNG.html">https://www.chronox.de/jent/doc/CPU-Jitter-NPTRNG.html</a></span>.
    Finally, exteral events (such as timing between keystroke, mouse movements,
    or network packet arrival) can be used to construct a RNG.
  </p>
  <p>
    System designers can also leverage physical uncloneable functions (PUF)s<span class="footnote"><a href="https://en.wikipedia.org/wiki/Physical_unclonable_function">https://en.wikipedia.org/wiki/Physical_unclonable_function</a></span>.
    PUFs depend on the uniqueness of random physical factors introduced during
    manufacturing. PUFs are typically designed to be stable over time, a
    property which isn't necessary in the RNG case.
  </p>

  <h2 class="count">Software Random Number Generator</h2>
  <p>
    Pseudo Random Number Generators (PRNG) are software based, deterministic,
    algorithms. A PRNG is typically seeded with the output of a HWRNG. The
    combination of HWRNG + PRNG enables secure random number generation at a
    high speed. When properly designed, it is unlikely for the RNG to become the
    bottleneck.
  </p>
  <p>
    One way to combine different RNGs is to build entropy pools. A slow (and possibly)
    biased HWRNG fills the first pool, which feeds into a second pool used by
    the PRNG. In such setups, it is common to preserve the entropy state between
    system reboots by writing the data to a file. It is common for these
    pools to be drawn in a simplified form<span class="footnote"><a href="https://blog.cloudflare.com/content/images/image01.png">image from "Ensuring Randomness with Linux's Random Number Generator"</a></span>,
    the reality is often more complex.
    <span class="footnote">https://www.2uo.de/myths-about-urandom/structure-new-728f5983.png</span>.
  </p>
  <p>
    Cryptographic protocols can be designed to take entropy from each party and
    mixing them. The ideal way to mix entropy is to use a cryptographic hash
    function. For example, TLS<span class="footnote">https://tls.ulfheim.net/</span>
    was designed with both, the client and server exchanging random data in their
    respective Hello messages.
  </p>

  <h2 class="count">You can never be sure</h2>
  <img src="https://assets.amuniversal.com/321a39e06d6401301d80001dd8b71c47">

  <p>
    One issue with RNG design is that you can never be sure if a generator
    is correct or not. The best we can do is run statistical tests and rule
    out generators which appear to be incorrect.
  </p>
  <p>
    Common statistical tests include NIST's NIST SP 800-22, https://csrc.nist.gov/Projects/Random-Bit-Generation/Documentation-and-Software
  </p>
  https://www.unf.edu/~cwinton/html/cop4300/s09/class.notes/c2-StatisticalTesting%20RNGsx.pdf
  Example tests:
  "Count the number of times a
member of the sequence falls into a given interval. The number
should be approximately the same for intervals of the same length
if the sequence is uniform. "

Count the number of times a k-tuple of
members of the sequence falls into a given k-dimensional cell. If
this test is passed, the sequence is said to be k-distributed.

Etc.
<p>
  List of some of the most popular PRNGs.
<div class="htimeline">
  <hr/>
  <div>
    <div class="desc">Middle-square method</div>
    <div class="sq"></div>
    <div class="label">1946</div>
  </div>
  <div>
    <div class="desc">Linear congruential generator</div>
    <div class="sq"></div>
    <div class="label">1958</div>
  </div>
  <div>
    <div class="desc">Linear feedback shift register</div>
    <div class="sq"></div>
    <div class="label">1965</div>
  </div>
  <div>
    <div class="desc">Mersenne Twister</div>
    <div class="sq"></div>
    <div class="label">1998</div>
  </div>
  <div>
    <div class="desc">Yarrow</div>
    <div class="sq"></div>
    <div class="label">1999</div>
  </div>
  <div>
    <div class="desc">Fortuna</div>
    <div class="sq"></div>
    <div class="label">2003</div>
  </div>
  <div>
    <div class="desc">Xorshift</div>
    <div class="sq"></div>
    <div class="label">2003</div>
  </div>
  <div>
    <div class="desc">Xoroshiro128+</div>
    <div class="sq"></div>
    <div class="label">2018</div>
  </div>
</div>
</p>

<p>Marsaglia’s 1995 Diehard collection</p>
<p>TestU01</p>
<p>generators in the PCG family do very well in statistical tests. https://www.pcg-random.org/pdf/hmc-cs-2014-0905.pdf
</p>
<p>BigCrush</p>
<p>Diceware</p>
ent utility from Fourmilab
NIST Statistical Test Suite (Special Publication 800-22 Revision 1a)
DieHarder: A Random Number Test Suite
Practically Random (PractRand)
BSI: Application Notes and Interpretation of the Scheme (AIS) 31 – Functionality Classes and Evaluation Methodology for Physical Random Number Generators, Version 1 (25.09.2001), English translation.
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_31_pdf.html
https://www.bsi.bund.de/SharedDocs/Downloads/DE/BSI/Zertifizierung/Interpretationen/AIS_20_AIS_31_Evaluation_of_random_number_generators_e.pdf?__blob=publicationFile
https://www.esat.kuleuven.be/cosic/publications/article-2896.pdf
https://www.systutorials.com/docs/linux/man/1-rngtest/


https://www.johndcook.com/blog/defensible-randomization/
http://www-users.math.umn.edu/~garrett/students/reu/pRNGs.pdf
https://www.schneier.com/wp-content/uploads/2017/10/paper-prngs.pdf

<p>https://www.pcg-random.org/index.html</p>
<p>Fortuna RNG</p>

https://en.wikipedia.org/wiki/Middle-square_method
https://en.wikipedia.org/wiki/Weyl_sequence
https://en.wikipedia.org/wiki/List_of_random_number_generators



  <h2 class="count">Overview of random number generator</h2>
  <p>In order to better understand real world random number generators, it's
    worth thinking about the ideal scenario.</p>

  <h2 class="count">Puzzle 1: biased coin</h2>
  <p><i>The solution to this puzzle is towards the end of this page.</i></p>

  <h2 class="count">Puzzle 2: RSA key generation</h2>
  <p><i>The solution to this puzzle is towards the end of this page.</i></p>
  <p>Generating a RSA key requires creating two primes. These primes need to
    each be large and secret. Given a RNG, how can you create two such
    primes?
  </p>

  <h2 class="count">Puzzle 3: sqrt(2) bias</h2>
  <p><i>The solution to this puzzle is towards the end of this page.</i></p>
  <p>Given a fair coin, build a RNG with prob(1) = 1/sqrt(2).</p>

  <h2 class="count">Puzzle 4: range</h2>
  <p><i>The solution to this puzzle is towards the end of this page.</i></p>
  <p>Given an infinite steam of randomly generated bytes (0-255), return values in the range 0-10.</p>

  <h2 class="count">Puzzle 5: float</h2>
  <p><i>The solution to this puzzle is towards the end of this page.</i></p>
  <p>Given an infinite steam of randomly generated bytes (0-255), return a float in the range 0-1.</p>
  <p>What about the range 0-10?</p>


  <h2 class="count">Hardware Random Number Generators</h2>
  <p>Note: I'm a software engineer. Take my information on hardware random
    number generators (HWRNG) with a grain of salt.</p>
  <p>There are two types of HWRNG: those using randomness coming from the
    environment (e.g. measure the minuscule difference in temperature on two different
    parts of a board) and hardware using physical properties which we believe
    to be random, to the best of our physics knowledge.</p>
  <p>
    The first type of HWRNG is cheap and easy to find. TODO examples.
  </p>
  <p>
    The second type is typically more expensive.
  </p>
  <p>While not a RNG, a good tool in the hardware designer's toolbox are
    physically uncloneable functions (PUFs). These are chips which have randomness
    injected in them at manufacturing time. In general, hardware engineers dislike
    pieces of hardware which are random, since testing can become challening.</p>

<!-- XKCD + Dilbert -->

  <h2 class="count">Failures</h2>
  <p>
    The purpose of this section is to learn from past mistakes. All
    these failures are attribuable to poor random number generation. In some
    cases, the lack of entropy could have been mitigated with a simple diode
    costing less than $1. In other cases, the root cause is software-related
    bugs, which are harder to prevent. Security engineering, as a field, still
    has lots of room to grow.
  </p>
  <p>
    In chronological order:
  </p>

  <div class="timeline">
    <div>
      <span>1940s</span>
      <p>
        Enigma was a mechanical cipher device used by various countries in the
        early 20th century. Enigma operators were supposed to pick three letters
        at random for their initial rotor positions. Humans tend to be poor at
        making random choices. Combined with other flaws, Allied cryptographers
        were able to completely break Enigma's cipher and decrypt important
        military secrets.
      </p>
      <hr/>
      <p>
        Around the same period, the U.S. Army's Signals Intelligence Service was
        able to solve a one-time pad system used by the German Foreign Office
        for its high-level traffic, codenamed GEE. GEE was insecure because the
        machine used to generate the pads produced predictable output.
      </p>
      <hr/>
      <p>
        Also around the same period, there are reports of other one-time
        pad failures. In some cases this was due to human errors. In other
        cases, the failure stemmed from poor processes to generate the one-time
        pad.
      </p>
      <p>
        <i>To be fair, generating random numbers at that time was much harder than
        today. The only reason I'm listing these events here is to remind people
        that random number generators influenced the outcome of wars.</i>
      </p>
    </div>

    <div>
      <span>1980</span>
      <p>
        Physical balls at Pennsylvania’s lottery were weighted, which resulted
        in higher likelyhood for certain numbers. In general, defending against
        insider attackers is very hard. In this case, the unusual betting
        patterns alerted authorities to the crime. The chief conspirators were
        sent to prison, and most of the fraudulently acquired winnings were
        never paid out.
      </p>
      <p><a href="https://www.pennlive.com/life/2020/04/convicted-bookie-helped-uncover-triple-six-fix-pa-lottery-scandal-40-years-ago.html">https://www.pennlive.com/life/2020/04/convicted-bookie-helped-uncover-triple-six-fix-pa-lottery-scandal-40-years-ago.html</a></p>
    </div>

    <div>
      <span>1995</span>
      <p>
        Netscape used PID, PPID, and time of day to seed SSL connections. The
        code was closed source, but Ian Goldberg and David Wagner reverse
        engineered the binary. While the cipher was weak (could be cracked in
        ~30 CPU hours), the weak random number generation made it possible to
        break the ciphertext in seconds.
      </p>
      <p><a href="https://people.eecs.berkeley.edu/~daw/papers/ddj-netscape.html">https://people.eecs.berkeley.edu/~daw/papers/ddj-netscape.html</a></p>
    </div>

    <div>
      <span>1999</span>
      <p>
        Brad Arkin, Frank Hill, Scott Marks, Matt Schmid, and Thomas John Walls
        find multiple flaws in an online poker site. The flaws include
        implementation bugs in the card shuffling algorithm as well as weak
        random number generation.
        https://www.developer.com/tech/article.php/616221/How-We-Learned-to-Cheat-at-Online-Poker-A-Study-in-Software-Security.htm
        https://web.archive.org/web/20040225194802/https://www.cigital.com/papers/download/developer_gambling.php
      </p>
    </div>

    <div>
      <span>2006</span>
      <p>
        Debian accidentally broke the OpenSSL random number generator while
        trying to silence a Valgrind warning. It is common for Debian maintainers
        to include custom patches. In this instance, the maintainer even asked
        for help on the OpenSSL mailing list and was given incorrect advice by
        two experts.
      </p>
      <p>
        <a href="https://lists.debian.org/debian-security-announce/2008/msg00152.html">CVE-2008-0166</a>, <a href="https://jblevins.org/log/ssh-vulnkey">https://jblevins.org/log/ssh-vulnkey</a>, and <a href="https://research.swtch.com/openssl">https://research.swtch.com/openssl</a>
      </p>
    </div>

    <div>
      <span>2007</span>
      <p>
        Dan Shumow and Niels Ferguson present that EC-DRBG, an algorithm
        standardized by NIST in 2006, could have potentially been backdoored
        using a technique published in 1997. After the Snowden revelations, NIST
        withdrew the algorithm in 2014.
      </p>
      <p>
        More info: <a href="http://rump2007.cr.yp.to/15-shumow.pdf">http://rump2007.cr.yp.to/15-shumow.pdf</a>,
        <a href="https://www.wired.com/2007/11/securitymatters-1115/">https://www.wired.com/2007/11/securitymatters-1115/</a>, and
        <a href="https://www.schneier.com/blog/archives/2007/11/the_strange_sto.html">https://www.schneier.com/blog/archives/2007/11/the_strange_sto.html</a>
      </p>
      <hr/>
      <p>
        In the same year, a team of Isreali researchers present flaws in Windows’ random number generator. <a href="https://eprint.iacr.org/2007/419.pdf">https://eprint.iacr.org/2007/419.pdf</a>.
      </p>
    </div>

    <div>
      <span>2010</span>
      <p>
        Playstation3 software suffered from a nonce reuse, which resulted in a
        private key recovery. In addition to using a strong source of randomness,
        Sony should have implemented deterministic ECDSA, an idea that had been
        around for ECDSA since 1997 (and formalized in 2013 as RFC-6979).
      </p>
    </div>

    <div>
      <span>2012</span>
      <p>
        Researchers from UC San Diego and UMich collected a large number of TLS
        certificates and were able to factor ~1% of keys due to weaknesses in
        the key generation. <a href="https://factorable.net/weakkeys12.extended.pdf">https://factorable.net/weakkeys12.extended.pdf</a>.
      </p>
      <p>
        At roughly the same time, Lenstra’s lab at EPFL performed a similar
        study, but focusing on GPG keys. They recovered ~0.2% of the keys.
        <a href="https://eprint.iacr.org/2012/064.pdf">https://eprint.iacr.org/2012/064.pdf</a>
      </p>

      <hr/>

      <p>
        The same year, Pokémon players abuse the RNG to get rare items.
        <a href="https://bulbapedia.bulbagarden.net/wiki/Pseudorandom_number_generation_in_Pok%C3%A9mon">https://bulbapedia.bulbagarden.net/wiki/Pseudorandom_number_generation_in_Pokémon</a>
      </p>
    </div>

    <div>
      <span>2013</span>
      <p>
        Android Zygote pre-initialized the OpenSSL RNG and then shared this
        pre-initialized state between all apps (all apps are forked at runtime
        from Zygote). OpenSSL had a defense in depth for that, which was to mix
        in the PID. Android reuses the PID. As a result, it's possible to get
        the same app launched twice on the same device, with the same PID. In
        such cases, the app would see the exact same output stream from the PRNG.
      </p>
      <p>
        If the app then performed ECDSA signatures, it would end up using the
        same k for its ECDSA signature, which leaks the private key in a way
        similar to Sony's 2010 issue. The fix was to ditch OpenSSL's PRNG
        implementation and replace it with reading from /dev/urandom. A system
        daemon also mixes in (at boot and every hour after that) a few kB of
        data read from /dev/hwrng (if present) into Linux PRNG.
      </p>
      <p>
        As a nuance, the actual PRNG dependency graph on modern Android is
        roughly: Java SecureRandom implementation that delegates to OpenSSL PRNG
        implementation that delegates to the Linux PRNG (by reading directly
        from /dev/urandom and returning that as the result to its caller). The
        reason for going with using the OpenSSL PRNG abstraction is that this
        way native platform code (such as the native TLS/SSL stack) that needs
        PRNG can (and does) use the OpenSSL PRNG.
      </p>
      <p>
        This Android Zygote bug resulted in the theft of at least 55 Bitcoins.
        <a href="https://blog.lxgr.net/posts/2013/08/15/android-securerandom-not-even-nonce/">https://blog.lxgr.net/posts/2013/08/15/android-securerandom-not-even-nonce/</a>
      </p>

      <hr/>

      <p>
        NetBSD: due to a misplaced parenthesis, if insufficient GOOD bits were
        available to satisfy a request, the keying/rekeying code requested
        either 32 or 64 ANY bits, rather than the balance of bits required to
        key the stream generator. <a href="https://ftp.netbsd.org/pub/NetBSD/security/advisories/NetBSD-SA2013-003.txt.asc">https://ftp.netbsd.org/pub/NetBSD/security/advisories/NetBSD-SA2013-003.txt.asc</a>.
      </p>

      <hr/>

      <p>
        The same year, Taiwan's National "Citizen Digital Certificate" smartcard
        database has 184 efficiently factorable keys.
      </p>

      <hr/>

      <p>
        "the srandomdev function in Libc in Apple Mac OS X before 10.9, when
        the kernel random-number generator is unavailable, produces predictable
        values instead of the intended random values. This makes it easier for
        context-dependent attackers to defeat cryptographic protection
        mechanisms by leveraging knowledge of these values, related to a
        compiler-optimization issue."
      </p>
    </div>

    <div>
      <span>2015</span>
      <p>
        Chrysler vehicle passwords are based on the time the car is turned on
        for the first time. A number of cars are remotely hackable. <a href="https://spectrum.ieee.org/cars-that-think/transportation/systems/jeep-hacking-101">https://spectrum.ieee.org/cars-that-think/transportation/systems/jeep-hacking-101</a>
      </p>
    </div>

    <div>
      <span>2017</span>
      <p>
        Slot machines with weak PRNGs were being exploited for financial gains.
        <a href="https://www.schneier.com/blog/archives/2017/02/predicting_a_sl.html">https://www.schneier.com/blog/archives/2017/02/predicting_a_sl.html</a>
      </p>
      <hr/>
      <p>
        Raspberry Pi has had a hardware RNG since at least 2013. For some
        reason, the driver to read from the hardware RNG was disabled in 2017,
        resulting in predictable ssh host keys:
        <a href="https://www.raspberrypi.org/forums/viewtopic.php?f=66&t=126892">https://www.raspberrypi.org/forums/viewtopic.php?f=66&t=126892</a>
      </p>
      <hr/>
      <p>
        PHP’s pseudo-random number generator (mt_rand) has a bias on 64-bit
        machines. <a href="https://bugs.php.net/bug.php?id=75170">https://bugs.php.net/bug.php?id=75170</a>.
        This wasn't the first issue with PHP's mt_rand. In 2008, a range isssue
        was partially fixed (<a href="https://bugs.php.net/bug.php?id=46587">https://bugs.php.net/bug.php?id=46587</a>)
        with the proper fix nine years later (<a href="https://bugs.php.net/bug.php?id=75514">https://bugs.php.net/bug.php?id=75514</a>).
        There was also issues around returning 31-bit instead of 32-bit values,
        and incorrectly scaling the desired range (<a href="https://bugs.php.net/bug.php?id=45184">https://bugs.php.net/bug.php?id=45184</a>).
      </p>
      <p>
        Correctness issues in mt_rand shouldn't be a concern, since mt_rand shouldn't
        be used for any cryptographic purpose. Web developers were however prone
        to using mt_rand for securing session cookies, which could then be
        attacked.
      </p>
      <hr/>
      <p>
        The same year, random number generators at various lotteries were rigged
        by an insider. Did I mention defending against insiders is hard?
        https://en.wikipedia.org/wiki/Hot_Lotto_fraud_scandal
      </p>
    </div>

    <div>
      <span>2021</span>
      <p>
        RDRAND on AMD Ryzen 9 5900X is perhaps flaky. https://github.com/systemd/systemd/issues/18184.
        Previous generations of Ryzen seem to also have had similar issues.
        https://linuxreviews.org/RDRAND_stops_returning_random_values_on_older_AMD_CPUs_after_suspend
        https://arstechnica.com/gadgets/2019/10/how-a-months-old-amd-microcode-bug-destroyed-my-weekend/
      </p>
    </div>
  </div>


  <h2 class="count">Solution to puzzle 2: RSA key generation</h2>
  <p class="spoiler">Spoiler!</p>
  <p>
    A naive method would be to randomly generate a number N, and then
    find the Nth prime. This wouldn't work well, because enumerating all
    primes is slow (O(N) operations and O(N) memory).
  </p>

  <p>
    The solution for generating large primes is to randomly generate a large
    number and then run some statistical tests to check whether it is prime.
    An RSA key is therefore only probabilistically secure, thankfully we get
    to pick what level of certainty we want.
  </p>
  https://github.com/openssl/openssl/blob/master/crypto/bn/bn_prime.c

  <p>
    Safe prime: https://en.wikipedia.org/wiki/Safe_and_Sophie_Germain_primes
    https://en.wikipedia.org/wiki/Primality_certificate
  </p>

  <h2 class="count">Solution to puzzle 5: float</h2>
  <p class="spoiler">Spoiler!</p>
  <p>

  The conventional method for generating a pseudorandom floating-point value is to generate a pseudorandom integer and divide by a constant (using floating-point arithmetic). The problems with this approach are (1) the possible outcomes are a small subset of the representable floating-point values (about $7%$ for a typical implementation) and (2) subsequent transformation of these values may not yield the expected distributions (for example, applying a log transformation to numbers from a uniform distribution does not yield an exponential distribution as it would in real arithmetic). We present a new algorithm with the following properties: (1) it can produce every representable floating-point value in a given range, and (2) it is efficient in both time and use of pseudorandom bits.
  </p>
  https://webcache.googleusercontent.com/search?q=cache:OM7YHIUrLIwJ:https://allendowney.com/research/rand/downey07randfloat.pdf+&cd=1&hl=en&ct=clnk&gl=us

  <h2 class="count">Tid bits</h2>
  <ol>
    <li>There's no such thing as a random number. A number can be randomly
    generated. Once generated, a number is just a number.</li>
    <li>There's heated debate on /dev/random vs /dev/urandom. Some systems have
      replaced /dev/urandom with a symlink. Lots of opiniated people.
      https://www.2uo.de/myths-about-urandom/
    </li>
    <li>The following command will fail to output different numbers:
<pre>zsh -c 'echo `echo $RANDOM`; echo `echo $RANDOM`'</pre>
        The similar command with bash works as expected (keep in mind that <code>$RANDOM</code> isn't
        a secure RNG):
<pre>bash -c 'echo `echo $RANDOM`; echo `echo $RANDOM`'</pre>
        The difference between <code>bash</code> and <code>zsh</code> include
        the way each shell handles sharing the seed with subshells.
        See https://nullprogram.com/blog/2018/12/25/ and https://linux.die.net/man/1/zshparam.
    </li>
  </ol>
  <p>



  <h2 class="count">Some generative-art</h2>
  <p>Re-implementation of a "maze" generator, from the Commodore 64 (1982) era.
    This short snippet of code was included in the user manual:</p>
<pre>10 PRINT CHR$(205.5+RND(1))
20 GOTO 10</pre>

  <p>The Commodore 64 had two fairly poor RNGs accessible via <code>RND()</code>.
    A beautiful and widely known hack<span class="footnote"><a href="https://www.atarimagazines.com/compute/issue72/random_numbers.php">https://www.atarimagazines.com/compute/issue72/random_numbers.php</a></span> involved sampling a noise signal from the
    Sound Interface Device!</p>
  <div id="art1">╲╱╱╱╲╱╲╲╲╲╲╲╲╱╲╲╲╲╱╲╱╱╱╲╱╱╱╲╱╱╱╲╲╱╱╲╱╲╱╱
╱╲╲╱╱╲╲╱╱╲╱╲╱╱╱╲╱╱╱╱╲╱╲╲╲╲╲╲╲╲╱╲╱╱╱╲╱╲╲╱
╲╲╱╱╱╱╱╲╲╱╱╲╲╱╱╱╲╲╱╱╲╲╱╱╱╲╲╲╱╱╱╱╲╱╲╱╲╱╲╱
╱╱╲╲╱╱╲╲╲╲╱╱╲╱╱╲╲╱╱╱╱╲╲╲╲╲╱╲╱╲╱╱╱╲╱╱╱╱╱╲
╲╱╱╱╱╱╱╲╱╲╱╲╱╲╱╱╲╱╲╲╲╲╲╲╲╱╱╲╱╲╱╲╲╲╲╲╱╲╲╱
╲╲╱╲╲╱╱╱╲╱╲╲╱╱╱╲╱╲╱╲╲╲╲╲╱╲╲╲╲╲╲╱╲╱╱╲╲╱╲╲
╱╲╲╱╱╱╱╲╱╲╱╱╱╱╲╱╱╱╱╱╱╲╲╲╱╲╲╲╱╱╲╲╱╱╱╱╱╱╱╱
╱╱╲╱╲╲╲╱╱╲╲╱╱╲╲╱╲╱╲╲╱╱╱╲╲╱╲╱╲╱╱╱╲╱╲╱╱╱╲╲
╱╲╱╲╲╱╱╱╲╱╱╱╲╲╲╲╱╱╲╱╲╱╱╲╲╱╲╱╱╱╲╱╲╲╲╱╲╲╲╲
╲╲╱╱╲╱╲╲╱╲╲╱╱╱╲╱╱╱╱╱╱╲╲╱╱╱╱╱╱╱╲╱╲╱╱╱╲╲╱╱
╲╲╲╱╲╱╲╱╱╲╲╱╲╱╱╱╱╱╲╱╲╱╱╱╱╲╱╲╱╲╲╲╱╲╲╲╱╲╲╱
╲╱╱╱╲╱╱╱╲╱╲╱╱╱╱╱╲╲╲╲╲╱╲╲╱╱╲╱╲╱╲╱╲╱╱╱╱╱╲╲
╲╱╲╲╱╲╱╲╱╱╲╲╱╲╱╱╱╲╱╱╱╱╲╱╱╱╲╱╲╲╱╱╲╲╲╲╱╱╲╱
╲╱╲╱╲╲╲╱╲╱╲╲╲╲╱╱╱╱╲╲╱╱╲╲╲╲╲╱╱╱╲╲╲╱╱╲╲╲╲╱
╲╱╱╱╱╲╲╱╱╲╱╱╲╲╱╱╲╲╲╱╱╱╱╱╱╱╱╱╲╱╱╱╲╱╱╲╱╲╲╲
╱╱╲╲╲╱╲╱╱╱╱╱╱╱╱╲╱╲╱╱╱╱╱╱╲╲╱╱╱╱╲╲╲╲╱╲╱╱╲╱
╱╱╱╱╲╲╲╱╱╱╱╲╲╲╱╱╲╲╱╲╲╲╱╲╲╲╲╱╲╱╱╲╲╲╲╱╲╱╲╲
╲╲╲╱╲╲╱╲╲╲╲╱╱╱╲╲╲╲╲╱╱╱╲╱╱╱╲╲╲╲╲╱╱╱╱╲╲╲╲╱
╲╱╱╲╱╱╲╲╲╲╲╲╲╲╲╱╱╲╱╲╲╲╲╱╱╲╲╱╲╱╲╱╱╱╲╱╲╱╱╲
╱╱╲╲╲╲╱╲╱╱╱╱╱╱╲╲╱╲╲╲╲╲╲╱╲╲╲╲╱╲╲╱╲╲╲╲╲╱╲╱
╲╱╱╲╱╲╱╲╱╲╲╲╱╲╲╲╲╲╲╲╱╲╲╲╲╱╱╱╱╱╱╱╲╱╲╲╲╲╲╲
╱╲╲╲╱╱╲╲╱╱╲╲╲╱╱╱╲╲╲╲╲╲╲╱╲╲╱╲╱╱╱╱╱╱╲╲╱╲╲╱
╱╱╱╱╲╱╱╱╱╲╲╱╲╲╱╲╲╲╱╲╱╲╱╲╲╱╱╲╲╲╲╲╱╲╱╲╱╲╱╱
╱╱╱╱╲╲╲╱╱╲╱╱╱╱╲╱╲╲╲╱╲╲╲╱╱╲╱╱╱╲╲╱╲╲╲╲╱╲╲╱
</div>
  <p>To learn more about maze generation, including <a href="https://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm">Eller's brilliant algorithm</a>
    to generate infinitely-scrolling mazes, check out
    <a href="https://pragprog.com/titles/jbmaze/mazes-for-programmers/">Mazes for Programmers</a> by Jamis Buck.</p>

  <h2 class="count">Closing thoughts</h2>
  <p>
    It seems some PRNGs generate similar streams for similar inputs (i.e. the
    stram for seed=N is similar to the stream for seed=N+1). If that is indeed
    true, we should probably always use a cryptographic hash function as
    part of the seeding process (i.e. use seed=hash(N) instead of seed=N).
  </p>
  <p align="right"><i>Alok Menghrajani</i></p>

  <!--

PRNG: given a finite state, the PRNG will inevitably loop. The interesting
property are:
- how long is the average loop for a given seed. How long is the worst
  case?
- given different seeds, how shuffled is the output.
- given similar seeds, how different is the output stream (avalanche effect).

Source of entropy vs RNG.

Java: -Djava.security.egd=file:/dev/./urandom
https://bugs.openjdk.java.net/browse/JDK-8143166



    <li>Random number types and their applications</li>
      <li>The ideal random number generator</li>
      <li>Linux: Entropy modeling</li>
      <li>Some randomly generated numbers</li>


Perfect RNG:
- a tree. Each process gets it's own "pool". Can't affect other processes.



Irrational number => RNG? Nope, 0.1010010001000010000001... is irrational. But
it wouldn't be a good RNG.


Quality of random number generators significantly affects results of Monte Carlo simulations for organic and biological systems

https://en.wikipedia.org/wiki/Spectral_test

https://www.pcg-random.org/posts/visualizing-the-heart-of-some-prngs.html

https://scholarworks.wmich.edu/cgi/viewcontent.cgi?article=2397&context=dissertations

http://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/

"(Incidentally, I was confused for a long time about the distinction between PRNGs and hash functions—they seem to do the same thing, i.e. create an “unpredictable” but deterministic output by jumbling up input bits. It wasn’t until I started playing around with GPU PRNGs that I realized the difference: PRNGs are designed for going deep, and hashes for going wide.)"

I wonder about the relative speed of bit-operations versus floating-point on dx11-GPUs - do you have any profiled results on this? Also, I guess it would be interesting to compare it to the currently most commonly used shader random-function, that uses a different category of functions:

//http://glsl.heroku.com/e#60...
float rand( vec2 n )
{
return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);
}

Geeky notes: The sinusoid based thing seems to stem from a stripped down Rey generator..never seen the article it's based on, but the documentation of TestU01 gives an overview and the source has an implementation. Other pure float RNGs that come to mind are various flavors of Weyl generators (again basics can be found with TestU01) and permutation polynomials (https://github.com/ashima/w.... My gut is that none of these are worth investigating. Oh there are others, like you can make a float LCG, but in singles...seems tough. I'll stop now because I'm being more noise than signal. :)

WRT: MurmurHash2 - Bad me, I was only thinking about the pre-hash part since it is separable. Dropping the final mix might be okay. Moving to a fragment shader, where you need to mix two or three values it should be a win.
https://github.com/ashima/webgl-noise

http://typeocaml.com/2015/11/22/visualise_random/

https://blog.trailofbits.com/2020/06/11/ecdsa-handle-with-care/

YubiKey RNG issue: https://www.yubico.com/support/security-advisories/ysa-2019-02/#technical-details

http://davidbau.com/archives/2010/01/30/random_seeds_coded_hints_and_quintillions.html

https://web.archive.org/web/20080706071139/http://www.cigital.com/papers/download/developer_gambling.php

https://www.2uo.de/myths-about-urandom/

RNG, PRNG, TRNG, CSPRNG

Practical Random Number Generation in Software
https://www.acsac.org/2003/papers/79.pdf

https://cryptotronix.com/2014/08/28/tpm-rng/

/dev/urandom vs /dev/random

https://www.infolipo.org/rencontres/rc2003/mnoll/noll2.html
Quality of random number generators significantly affects results of Monte Carlo simulations for organic and biological systems

Random Number Generator Recommendations for Applications
https://peteroupc.github.io/random.html

https://www.random.org/randomness/

https://www.quora.com/What-are-the-practical-applications-of-random-number-generators
Digital display: when rotating or scaling a digital image, the discretization will lead to highly visible display artifacts unless it is counteracted. This is often done using randomization within the pixel area. Someone posted an example on Quora recently using a picture of a brick wall; I can't find the link.
Computer opponents: rather than do the same thing every time, they can choose randomly among plausible alternatives.
MIT has an entire class (6.856)

https://cryptotronix.com/2014/08/28/tpm-rng/

https://www.schneier.com/academic/fortuna/
https://arxiv.org/pdf/1908.10020.pdf

https://nickm.com/trope_tank/10_PRINT_121114.pdf
https://retrocomputing.stackexchange.com/questions/2244/how-was-early-randomness-generated
https://en.wikipedia.org/wiki/RANDU
https://www.atarimagazines.com/compute/issue72/random_numbers.php

https://security.stackexchange.com/questions/222607/is-reading-from-dev-urandom-on-macos-catalina-a-safe-way-to-produce-cryptograph
https://www.pagetable.com/c64ref/c64disasm/
https://github.com/choas/C64-BASIC-iOS-cbmbasic/blob/master/Cbmbasic/CbmBasic/Dependencies/cbmbasic/runtime.c#L769
https://www.larsgregori.de/2020/05/24/c64-basic-how-i-fixed-rnd/

https://lkml.org/lkml/2016/10/21/982
https://francozappa.github.io/publication/master-thesis/thesis.pdf
https://support.apple.com/guide/security/random-number-generation-seca0c73a75b/web
https://systemd.io/RANDOM_SEEDS/

https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4705093

https://www.2uo.de/myths-about-urandom/#true-randomness

/dev/arandom, /dev/prandom? /dev/wrandom? http://www.mirbsd.org/htman/i386/man4/random.htm

but passing any number of empirical tests can never prove the
absence of defects.

Virtual machine: re-using seed/state from host + preserve state across restarts.

java /./dev/urandom thing

  -->
  </div>
</body>
</html>
